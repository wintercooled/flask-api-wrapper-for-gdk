# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")


def swig_import_helper():
    import importlib
    pkg = __name__.rpartition('.')[0]
    mname = '.'.join((pkg, 'libgreenaddress')).lstrip('.')
    try:
        return importlib.import_module(mname)
    except ImportError:
        return importlib.import_module('libgreenaddress')
libgreenaddress = swig_import_helper()
del swig_import_helper


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


GA_OK = libgreenaddress.GA_OK
GA_ERROR = libgreenaddress.GA_ERROR
GA_RECONNECT = libgreenaddress.GA_RECONNECT
GA_SESSION_LOST = libgreenaddress.GA_SESSION_LOST
GA_TIMEOUT = libgreenaddress.GA_TIMEOUT
GA_NOT_AUTHORIZED = libgreenaddress.GA_NOT_AUTHORIZED
GA_NONE = libgreenaddress.GA_NONE
GA_INFO = libgreenaddress.GA_INFO
GA_DEBUG = libgreenaddress.GA_DEBUG
GA_TRUE = libgreenaddress.GA_TRUE
GA_FALSE = libgreenaddress.GA_FALSE

def init(config: "GA_json const *") -> "int":
    return libgreenaddress.init(config)

def create_session() -> "struct GA_session **":
    return libgreenaddress.create_session()

def destroy_session(session: "struct GA_session *") -> "int":
    return libgreenaddress.destroy_session(session)

def connect(session: "struct GA_session *", net_params: "GA_json const *") -> "int":
    return libgreenaddress.connect(session, net_params)

def reconnect_hint(session: "struct GA_session *", hint: "GA_json const *") -> "int":
    return libgreenaddress.reconnect_hint(session, hint)

def get_proxy_settings(session: "struct GA_session *") -> "GA_json **":
    return libgreenaddress.get_proxy_settings(session)

def get_wallet_identifier(net_params: "GA_json const *", params: "GA_json const *") -> "GA_json **":
    return libgreenaddress.get_wallet_identifier(net_params, params)

def http_request(session: "struct GA_session *", params: "GA_json const *") -> "GA_json **":
    return libgreenaddress.http_request(session, params)

def refresh_assets(session: "struct GA_session *", params: "GA_json const *") -> "GA_json **":
    return libgreenaddress.refresh_assets(session, params)

def validate_asset_domain_name(session: "struct GA_session *", params: "GA_json const *") -> "GA_json **":
    return libgreenaddress.validate_asset_domain_name(session, params)

def register_user(session: "struct GA_session *", hw_device: "GA_json const *", mnemonic: "char const *") -> "struct GA_auth_handler **":
    return libgreenaddress.register_user(session, hw_device, mnemonic)

def login_user(session: "struct GA_session *", hw_device: "GA_json const *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.login_user(session, hw_device, details)

def set_watch_only(session: "struct GA_session *", username: "char const *", password: "char const *") -> "int":
    return libgreenaddress.set_watch_only(session, username, password)

def get_watch_only_username(session: "struct GA_session *") -> "char **":
    return libgreenaddress.get_watch_only_username(session)

def remove_account(session: "struct GA_session *") -> "struct GA_auth_handler **":
    return libgreenaddress.remove_account(session)

def create_subaccount(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.create_subaccount(session, details)

def get_subaccounts(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_subaccounts(session, details)

def get_subaccount(session: "struct GA_session *", subaccount: "uint32_t") -> "struct GA_auth_handler **":
    return libgreenaddress.get_subaccount(session, subaccount)

def rename_subaccount(session: "struct GA_session *", subaccount: "uint32_t", new_name: "char const *") -> "int":
    return libgreenaddress.rename_subaccount(session, subaccount, new_name)

def update_subaccount(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.update_subaccount(session, details)

def get_transactions(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_transactions(session, details)

def get_receive_address(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_receive_address(session, details)

def get_previous_addresses(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_previous_addresses(session, details)

def get_unspent_outputs(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_unspent_outputs(session, details)

def get_unspent_outputs_for_private_key(session: "struct GA_session *", private_key: "char const *", password: "char const *", unused: "uint32_t") -> "GA_json **":
    return libgreenaddress.get_unspent_outputs_for_private_key(session, private_key, password, unused)

def set_unspent_outputs_status(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.set_unspent_outputs_status(session, details)

def get_transaction_details(session: "struct GA_session *", txhash_hex: "char const *") -> "GA_json **":
    return libgreenaddress.get_transaction_details(session, txhash_hex)

def get_balance(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.get_balance(session, details)

def get_available_currencies(session: "struct GA_session *") -> "GA_json **":
    return libgreenaddress.get_available_currencies(session)

def convert_amount(session: "struct GA_session *", value_details: "GA_json const *") -> "GA_json **":
    return libgreenaddress.convert_amount(session, value_details)

def set_pin(session: "struct GA_session *", mnemonic: "char const *", pin: "char const *", device_id: "char const *") -> "GA_json **":
    return libgreenaddress.set_pin(session, mnemonic, pin, device_id)

def disable_all_pin_logins(session: "struct GA_session *") -> "int":
    return libgreenaddress.disable_all_pin_logins(session)

def create_transaction(session: "struct GA_session *", transaction_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.create_transaction(session, transaction_details)

def sign_transaction(session: "struct GA_session *", transaction_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.sign_transaction(session, transaction_details)

def psbt_sign(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.psbt_sign(session, details)

def psbt_get_details(session: "struct GA_session *", details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.psbt_get_details(session, details)

def broadcast_transaction(session: "struct GA_session *", transaction_hex: "char const *") -> "char **":
    return libgreenaddress.broadcast_transaction(session, transaction_hex)

def send_transaction(session: "struct GA_session *", transaction_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.send_transaction(session, transaction_details)

def send_nlocktimes(session: "struct GA_session *") -> "int":
    return libgreenaddress.send_nlocktimes(session)

def set_csvtime(session: "struct GA_session *", locktime_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.set_csvtime(session, locktime_details)

def set_nlocktime(session: "struct GA_session *", locktime_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.set_nlocktime(session, locktime_details)

def set_transaction_memo(session: "struct GA_session *", txhash_hex: "char const *", memo: "char const *", memo_type: "uint32_t") -> "int":
    return libgreenaddress.set_transaction_memo(session, txhash_hex, memo, memo_type)

def get_fee_estimates(session: "struct GA_session *") -> "GA_json **":
    return libgreenaddress.get_fee_estimates(session)

def get_mnemonic_passphrase(session: "struct GA_session *", password: "char const *") -> "char **":
    return libgreenaddress.get_mnemonic_passphrase(session, password)

def get_system_message(session: "struct GA_session *") -> "char **":
    return libgreenaddress.get_system_message(session)

def ack_system_message(session: "struct GA_session *", message_text: "char const *") -> "struct GA_auth_handler **":
    return libgreenaddress.ack_system_message(session, message_text)

def get_twofactor_config(session: "struct GA_session *") -> "GA_json **":
    return libgreenaddress.get_twofactor_config(session)

def change_settings(session: "struct GA_session *", settings: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.change_settings(session, settings)

def get_settings(session: "struct GA_session *") -> "GA_json **":
    return libgreenaddress.get_settings(session)

def auth_handler_get_status(call: "struct GA_auth_handler *") -> "GA_json **":
    return libgreenaddress.auth_handler_get_status(call)

def auth_handler_request_code(call: "struct GA_auth_handler *", method: "char const *") -> "int":
    return libgreenaddress.auth_handler_request_code(call, method)

def auth_handler_resolve_code(call: "struct GA_auth_handler *", code: "char const *") -> "int":
    return libgreenaddress.auth_handler_resolve_code(call, code)

def auth_handler_call(call: "struct GA_auth_handler *") -> "int":
    return libgreenaddress.auth_handler_call(call)

def destroy_auth_handler(call: "struct GA_auth_handler *") -> "int":
    return libgreenaddress.destroy_auth_handler(call)

def change_settings_twofactor(session: "struct GA_session *", method: "char const *", twofactor_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.change_settings_twofactor(session, method, twofactor_details)

def twofactor_reset(session: "struct GA_session *", email: "char const *", is_dispute: "uint32_t") -> "struct GA_auth_handler **":
    return libgreenaddress.twofactor_reset(session, email, is_dispute)

def twofactor_undo_reset(session: "struct GA_session *", email: "char const *") -> "struct GA_auth_handler **":
    return libgreenaddress.twofactor_undo_reset(session, email)

def twofactor_cancel_reset(session: "struct GA_session *") -> "struct GA_auth_handler **":
    return libgreenaddress.twofactor_cancel_reset(session)

def twofactor_change_limits(session: "struct GA_session *", limit_details: "GA_json const *") -> "struct GA_auth_handler **":
    return libgreenaddress.twofactor_change_limits(session, limit_details)

def get_random_bytes(num_bytes: "size_t", output_bytes: "unsigned char *") -> "int":
    return libgreenaddress.get_random_bytes(num_bytes, output_bytes)

def generate_mnemonic() -> "char **":
    return libgreenaddress.generate_mnemonic()

def generate_mnemonic_12() -> "char **":
    return libgreenaddress.generate_mnemonic_12()

def validate_mnemonic(mnemonic: "char const *") -> "uint32_t *":
    return libgreenaddress.validate_mnemonic(mnemonic)

def register_network(name: "char const *", network_details: "GA_json const *") -> "int":
    return libgreenaddress.register_network(name, network_details)

def get_networks() -> "GA_json **":
    return libgreenaddress.get_networks()

def get_uniform_uint32_t(upper_bound: "uint32_t") -> "uint32_t *":
    return libgreenaddress.get_uniform_uint32_t(upper_bound)

def _python_set_callback_handler(obj: "PyObject *", arg: "PyObject *") -> "int":
    return libgreenaddress._python_set_callback_handler(obj, arg)

def _python_destroy_session(obj: "PyObject *") -> "int":
    return libgreenaddress._python_destroy_session(obj)


import atexit
import json
try:
    import queue
except:
    import Queue as queue

try:
    basestring
except NameError:
    basestring = str

# Unused: Provided for back compatibility only
GA_MEMO_USER = 0
GA_MEMO_BIP70 = 1

class Call(object):
    """Handler class to process a call potentally requiring twofactor.

    Initialize the class with the auth_handler object returned from
    functions that may require authentication. Then call resolve()
    on the object, optionally passing in callables to select and enter
    twofactor auth methods and codes.

    """

    def __init__(self, call_obj):
        self.call_obj = call_obj

    def status(self):
        return json.loads(auth_handler_get_status(self.call_obj))

    def _select_method(self, methods):
        # Default implementation just uses the first method provided
        return methods[0]

    def _resolve_code(self, method):
        # Default implementation just uses localtest dummy 2fa code
        return '555555'

    def request_code(self, method):
        auth_handler_request_code(self.call_obj, method)

    def resolve(self, select_method_fn=None, resolve_code_fn=None):
        select_method_fn = select_method_fn or self._select_method
        resolve_code_fn = resolve_code_fn or self._resolve_code
        while True:
            status = self.status()
            state = status['status']
            if state == 'error':
                self.call_obj = None
                raise RuntimeError(status['error'])
            if state == 'done':
                self.call_obj = None
                return status['result']
            if state == 'request_code':
                method = select_method_fn(status['methods'])
                auth_handler_request_code(self.call_obj, method)
            elif state == 'resolve_code':
                if 'required_data' in status:
                    # Hardware device authorization requested
                    code = resolve_code_fn(status['required_data'])
                else:
                    # Twofactor authorization requested
                    code = resolve_code_fn(status['method'])
                auth_handler_resolve_code(self.call_obj, code)
            elif state == 'call':
                auth_handler_call(self.call_obj)


class Session(object):
    """A session representing either a Green multisig or a singlesig wallet.

    """

    to_destroy = []

    @staticmethod
    @atexit.register
    def destroy_all():
        while len(Session.to_destroy):
            session = Session.to_destroy.pop()
            session._destroy()

    def __init__(self, net_params):
        self.notifications = queue.Queue()
        self.session_obj = create_session()
        Session.to_destroy.append(self)
        _python_set_callback_handler(self.session_obj, self._callback_handler)
        return self.connect(net_params)

    def _destroy(self):
        if getattr(self, 'session_obj', None):
            obj = self.session_obj
            self.session_obj = None
            _python_set_callback_handler(obj, None)
            _python_destroy_session(obj)

    def destroy(self):
        if self in Session.to_destroy:
            Session.to_destroy.remove(self)
            self._destroy()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.destroy()

    def __del__(self):
        self.destroy()

    def _callback_handler(self, obj, event):
        assert obj is self.session_obj
        try:
            self.callback_handler(json.loads(event))
        except Exception as e:
            print('exception {}\n'.format(e))

    def callback_handler(self, event):
        """Callback handler.

         Override or monkey patch to handle notifications, or read the
         self.notification queue to receive events.

         """
        timeout_seconds = 60
        self.notifications.put(event, timeout_seconds)

    @staticmethod
    def _to_json(obj):
        return obj if isinstance(obj, basestring) else json.dumps(obj)

    def connect(self, net_params):
        return connect(self.session_obj, self._to_json(net_params))

    def disconnect(self):
        raise RuntimeError('use reconnect_hint() to disconnect a session')

    def reconnect_hint(self, hint):
        return reconnect_hint(self.session_obj, self._to_json(hint))

    def get_proxy_settings(self):
        return json.loads(get_proxy_settings(self.session_obj))

    @staticmethod
    def get_wallet_identifier(net_params, params):
        return json.loads(get_wallet_identifier(Session._to_json(net_params), Session._to_json(params)))

    def register_user(self, hw_device, mnemonic):
        return Call(register_user(self.session_obj, self._to_json(hw_device), mnemonic))

    def login_user(self, hw_device, details):
        return Call(login_user(self.session_obj, self._to_json(hw_device), self._to_json(details)))

    def set_watch_only(self, username, password):
        set_watch_only(self.session_obj, username, password)
        return self

    def get_watch_only_username(self):
        return get_watch_only_username(self.session_obj)

    def remove_account(self):
        return Call(remove_account(self.session_obj))

    def set_pin(self, mnemonic, pin, device_id):
        return json.loads(set_pin(self.session_obj, mnemonic, pin, device_id))

    def disable_all_pin_logins(self):
        return disable_all_pin_logins(self.session_obj)

    def create_subaccount(self, details):
        return Call(create_subaccount(self.session_obj, self._to_json(details)))

    def rename_subaccount(self, subaccount, new_name):
        return rename_subaccount(self.session_obj, subaccount, new_name)

    def update_subaccount(self, details):
        return Call(update_subaccount(self.session_obj, self._to_json(details)))

    def get_subaccounts(self, details=None):
        details = details or {}
        return Call(get_subaccounts(self.session_obj, self._to_json(details)))

    def get_subaccount(self, subaccount):
        return Call(get_subaccount(self.session_obj, subaccount))

    def get_transactions(self, details={'subaccount': 0, 'first': 0, 'count': 30}):
        return Call(get_transactions(self.session_obj, self._to_json(details)))

    def get_receive_address(self, details=None):
        details = details or {}
        return Call(get_receive_address(self.session_obj, self._to_json(details)))

    def get_previous_addresses(self, details={'subaccount': 0, 'last_pointer': 0}):
        return Call(get_previous_addresses(self.session_obj, self._to_json(details)))

    def get_unspent_outputs(self, details={'subaccount': 0, 'num_confs': 1}):
        return Call(get_unspent_outputs(self.session_obj, self._to_json(details)))

    def get_unspent_outputs_for_private_key(self, private_key, password, unused):
        return json.loads(
            get_unspent_outputs_for_private_key(self.session_obj, private_key, password, unused)
        )

    def set_unspent_outputs_status(self, details):
        return Call(set_unspent_outputs_status(self.session_obj, self._to_json(details)))

    def get_transaction_details(self, txhash_hex):
        return json.loads(get_transaction_details(self.session_obj, txhash_hex))

    def convert_amount(self, details):
        return json.loads(convert_amount(self.session_obj, self._to_json(details)))

    def get_balance(self, details={'subaccount': 0, 'num_confs': 0}):
        return Call(get_balance(self.session_obj, self._to_json(details)))

    def get_available_currencies(self):
        return json.loads(get_available_currencies(self.session_obj))

    def create_transaction(self, transaction_details):
        return Call(create_transaction(self.session_obj, self._to_json(transaction_details)))

    def sign_transaction(self, transaction_details):
        return Call(sign_transaction(self.session_obj, self._to_json(transaction_details)))

    def psbt_sign(self, details):
        return Call(psbt_sign(self.session_obj, self._to_json(details)))

    def psbt_get_details(self, details):
        return Call(psbt_get_details(self.session_obj, self._to_json(details)))

    def send_transaction(self, transaction_details):
        return Call(send_transaction(self.session_obj, self._to_json(transaction_details)))

    def broadcast_transaction(self, tx_hex):
        return broadcast_transaction(self.session_obj, tx_hex)

    def send_nlocktimes(self):
        return send_nlocktimes(self.session_obj)

    def set_csvtime(self, locktime_details):
        return Call(set_csvtime(self.session_obj, self._to_json(locktime_details)))

    def set_nlocktime(self, locktime_details):
        return Call(set_nlocktime(self.session_obj, self._to_json(locktime_details)))

    def set_transaction_memo(self, txhash_hex, memo, memo_type=0):
        return set_transaction_memo(self.session_obj, txhash_hex, memo, memo_type)

    def get_fee_estimates(self):
        return json.loads(get_fee_estimates(self.session_obj))

    def get_mnemonic_passphrase(self, password):
        return get_mnemonic_passphrase(self.session_obj, password)

    def get_system_message(self):
        return get_system_message(self.session_obj)

    def ack_system_message(self, message_text):
        return Call(ack_system_message(self.session_obj, message_text))

    def get_twofactor_config(self):
        return json.loads(get_twofactor_config(self.session_obj))

    def change_settings_twofactor(self, method, details):
        return Call(change_settings_twofactor(self.session_obj, method, self._to_json(details)))

    def get_settings(self):
        return json.loads(get_settings(self.session_obj))

    def change_settings(self, settings):
        return Call(change_settings(self.session_obj, self._to_json(settings)))

    def twofactor_reset(self, email, is_dispute):
        return Call(twofactor_reset(self.session_obj, email, is_dispute))

    def twofactor_undo_reset(self, email):
        return Call(twofactor_undo_reset(self.session_obj, email))

    def twofactor_cancel_reset(self):
        return Call(twofactor_cancel_reset(self.session_obj))

    def twofactor_change_limits(self, details):
        return Call(twofactor_change_limits(self.session_obj, self._to_json(details)))

    def http_request(self, params):
        return json.loads(http_request(self.session_obj, self._to_json(params)))

    def refresh_assets(self, params):
        return json.loads(refresh_assets(self.session_obj, self._to_json(params)))

    def validate_asset_domain_name(self, params):
        return json.loads(validate_asset_domain_name(self.session_obj, self._to_json(params)))


_old_get_networks = get_networks
def get_networks():
    return json.loads(_old_get_networks())

_old_register_network = register_network
def register_network(name, details):
    return _old_register_network(name, Session._to_json(details))

_old_get_random_bytes = get_random_bytes
def get_random_bytes(n):
    out = bytearray(n)
    _old_get_random_bytes(n, out)
    return bytes(out)

_old_init = init
def init(config):
    import os, os.path
    if not config.get('datadir', None):
        try:
            datadir = os.path.join(os.path.expanduser('~'), '.blockstream', 'gdk')
            os.makedirs(os.path.join(datadir, 'assets'), exist_ok = True);
            config['datadir'] = datadir
        except:
          pass
    return _old_init(json.dumps(config))
